<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Don't use this in production: -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      function MyApp() {
        const handleSubmit = React.useCallback(() => {
          console.log(
            '你想要缓存的函数值。它可以接受任何参数并返回任何值。在初始渲染期间，React 将把你的函数返回给你（而不是调用！）。在下一次渲染时，如果依赖项自上次渲染以来没有更改，则 React 会再次给出相同的函数。否则，它将为您提供在当前呈现期间传递的函数，并将其存储起来以备后续重用。React 不会调用您的函数。该功能被返回给您，因此您可以决定何时以及是否调用它。'
          )
          console.log(
            '在 fn 代码内引用的所有响应式值列表。 响应式值包括 props、state 和直接在组件主体内声明的所有变量和函数。 如果您的 linter 配置为 React，则它将验证每个响应式值是否正确指定为依赖项。 依赖项列表必须具有恒定数量的项目，并且像 [dep1，dep2，dep3] 这样编写成一行。React 将使用 Object.is 比较算法将每个依赖项与其先前的值进行比较。'
          )
        }, [])
        return <button onClick={handleSubmit}>useCallback</button>
      }

      const container = document.getElementById('root')
      const root = ReactDOM.createRoot(container)
      root.render(<MyApp />)
    </script>
  </body>
</html>
